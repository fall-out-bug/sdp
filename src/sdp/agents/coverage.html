
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agents: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/fall-out-bug/sdp/src/sdp/agents/code_analyzer.go (81.9%)</option>
				
				<option value="file1">github.com/fall-out-bug/sdp/src/sdp/agents/contract_generator.go (85.7%)</option>
				
				<option value="file2">github.com/fall-out-bug/sdp/src/sdp/agents/contract_validator.go (85.1%)</option>
				
				<option value="file3">github.com/fall-out-bug/sdp/src/sdp/agents/synthesis_agent.go (82.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package agents

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "gopkg.in/yaml.v3"
)

const (
        // MaxRegexMatchSize limits the size of regex matches to prevent ReDoS
        MaxRegexMatchSize = 10000
        // RegexTimeout is the maximum time to spend on regex operations
        RegexTimeout = 5 * time.Second
)

// CodeAnalyzer extracts API contracts from existing code
type CodeAnalyzer struct{}

// ExtractedRoute represents a backend route
type ExtractedRoute struct {
        Path   string `yaml:"path"`
        Method string `yaml:"method"`
        File   string `yaml:"file"`
        Line   int    `yaml:"line"`
}

// ExtractedCall represents a frontend API call
type ExtractedCall struct {
        Path   string `yaml:"path"`
        Method string `yaml:"method"`
        File   string `yaml:"file"`
        Line   int    `yaml:"line"`
}

// ExtractedMethod represents a Python SDK method
type ExtractedMethod struct {
        Name        string   `yaml:"name"`
        Parameters  []string `yaml:"parameters"`
        ReturnType  string   `yaml:"return_type"`
        Description string   `yaml:"description"`
        File        string   `yaml:"file"`
        Line        int      `yaml:"line"`
}

// NewCodeAnalyzer creates a new code analyzer
func NewCodeAnalyzer() *CodeAnalyzer <span class="cov8" title="1">{
        return &amp;CodeAnalyzer{}
}</span>

// safeCompileRegex compiles a regex with timeout and size limits
func safeCompileRegex(pattern string) (*regexp.Regexp, error) <span class="cov0" title="0">{
        // Add timeout context
        ctx, cancel := context.WithTimeout(context.Background(), RegexTimeout)
        defer cancel()

        // Compile regex
        re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid regex pattern: %w", err)
        }</span>

        // Test regex with pathological input to detect ReDoS
        <span class="cov0" title="0">pathologicalInput := strings.Repeat("a", 1000) + "!\""
        testChan := make(chan bool, 1)

        go func() </span><span class="cov0" title="0">{
                // This should complete quickly for safe regex
                re.FindStringSubmatch(pathologicalInput)
                testChan &lt;- true
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-testChan:<span class="cov0" title="0">
                // Regex is safe (completed in time)
                return re, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                // Regex timed out - potential ReDoS
                return nil, fmt.Errorf("regex pattern potentially vulnerable to ReDoS: timeout after %v", RegexTimeout)</span>
        }
}

// truncateInput limits input size to prevent ReDoS
func truncateInput(input string) string <span class="cov8" title="1">{
        if len(input) &gt; MaxRegexMatchSize </span><span class="cov0" title="0">{
                return input[:MaxRegexMatchSize]
        }</span>
        <span class="cov8" title="1">return input</span>
}

// AnalyzeGoBackend extracts routes from Go backend code
func (ca *CodeAnalyzer) AnalyzeGoBackend(filePath string) ([]ExtractedRoute, error) <span class="cov8" title="1">{
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read Go file: %w", err)
        }</span>

        // Check file size before processing
        <span class="cov8" title="1">if len(content) &gt; MaxRegexMatchSize*10 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file too large for analysis: %d bytes (max %d)", len(content), MaxRegexMatchSize*10)
        }</span>

        <span class="cov8" title="1">var routes []ExtractedRoute
        lines := strings.Split(string(content), "\n")

        // Safe regex patterns for different frameworks
        // FIXED: Avoided catastrophic backtracking by:
        // 1. Using more explicit patterns (no ambiguous optional prefixes)
        // 2. Limiting character classes to prevent overlap
        // 3. Using atomic grouping where possible
        patterns := []struct {
                Name    string
                Pattern *regexp.Regexp
        }{
                {
                        Name:    "gorilla/mux",
                        // FIXED: More explicit pattern, no nested quantifiers, quote outside capture group
                        Pattern: regexp.MustCompile(`HandleFunc\("([^"]{1,200})",\s*(\w+)\)\.Methods\("(\w{3,7})"\)`),
                },
                {
                        Name: "gin",
                        // FIXED: Removed ambiguous r? prefix, use alternation instead
                        Pattern: regexp.MustCompile(`(?:router|r)?\.(GET|POST|PUT|DELETE|PATCH)\("([^"]{1,200})",\s*(\w+)\)`),
                },
                {
                        Name: "echo",
                        // FIXED: Removed ambiguous e? prefix, use alternation instead
                        Pattern: regexp.MustCompile(`(?:echo|e)?\.(GET|POST|PUT|DELETE|PATCH)\("([^"]{1,200})",\s*(\w+)\)`),
                },
        }

        for lineNum, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)

                // Skip overly long lines
                if len(line) &gt; MaxRegexMatchSize </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Try each pattern
                <span class="cov8" title="1">for _, p := range patterns </span><span class="cov8" title="1">{
                        matches := p.Pattern.FindStringSubmatch(line)
                        if len(matches) &gt;= 3 </span><span class="cov8" title="1">{
                                var path, method string

                                // Extract path and method based on pattern
                                switch p.Name </span>{
                                case "gorilla/mux":<span class="cov8" title="1">
                                        path = matches[1]
                                        method = matches[3]</span>
                                case "gin", "echo":<span class="cov8" title="1">
                                        method = matches[1]
                                        path = matches[2]</span>
                                }

                                <span class="cov8" title="1">routes = append(routes, ExtractedRoute{
                                        Path:   path,
                                        Method: strings.ToUpper(method),
                                        File:   filePath,
                                        Line:   lineNum + 1,
                                })
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return routes, nil</span>
}

// AnalyzeTypeScriptFrontend extracts API calls from TypeScript/JavaScript
func (ca *CodeAnalyzer) AnalyzeTypeScriptFrontend(filePath string) ([]ExtractedCall, error) <span class="cov8" title="1">{
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read TypeScript file: %w", err)
        }</span>

        // Check file size
        <span class="cov8" title="1">if len(content) &gt; MaxRegexMatchSize*10 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file too large for analysis: %d bytes (max %d)", len(content), MaxRegexMatchSize*10)
        }</span>

        <span class="cov8" title="1">var calls []ExtractedCall
        contentStr := string(content)

        // Truncate content if too large
        contentStr = truncateInput(contentStr)

        // FIXED: Safe regex patterns with explicit limits
        // First, process multiline patterns on the entire content
        multilinePatterns := []struct {
                Name    string
                Pattern *regexp.Regexp
                Method  string
        }{
                {
                        Name:    "fetch with method (multiline)",
                        // FIXED: Added non-greedy quantifier and explicit length limits
                        Pattern: regexp.MustCompile(`fetch\("([^"]{1,200})",\s*\{[\s\S]{0,500}?method:\s*["'](\w+)["'][\s\S]{0,500}?\}`),
                        Method:  "",
                },
                {
                        Name:    "fetch GET (multiline with .then)",
                        // FIXED: Limited multiline match to 500 chars
                        Pattern: regexp.MustCompile(`fetch\("([^"]{1,200}")\)[\s\S]{0,300}?\.then\(`),
                        Method:  "GET",
                },
        }

        // Find all multiline matches
        for _, p := range multilinePatterns </span><span class="cov8" title="1">{
                allMatches := p.Pattern.FindAllStringSubmatchIndex(contentStr, -1)
                for _, match := range allMatches </span><span class="cov8" title="1">{
                        if len(match) &gt;= 6 </span><span class="cov8" title="1">{
                                // Extract matched text
                                matchedText := contentStr[match[0]:match[1]]
                                // Find line number by counting newlines before match
                                lineNum := strings.Count(contentStr[:match[0]], "\n")

                                // Extract submatches
                                submatches := p.Pattern.FindStringSubmatch(matchedText)
                                if len(submatches) &gt;= 3 </span><span class="cov8" title="1">{
                                        calls = append(calls, ExtractedCall{
                                                Path:   submatches[1],
                                                Method: strings.ToUpper(submatches[2]),
                                                File:   filePath,
                                                Line:   lineNum + 1,
                                        })
                                }</span>
                        }
                }
        }

        // Then process line-by-line for simple patterns
        <span class="cov8" title="1">lines := strings.Split(contentStr, "\n")
        simplePatterns := []struct {
                Name    string
                Pattern *regexp.Regexp
                Method  string
        }{
                {
                        Name:    "fetch simple (single line, no comma or brace)",
                        // FIXED: Added explicit length limit
                        Pattern: regexp.MustCompile(`fetch\("([^"]{1,200}")`),
                        Method:  "GET",
                },
                {
                        Name:    "axios",
                        // FIXED: Added explicit length limit to method and path
                        Pattern: regexp.MustCompile(`axios\.(\w{3,7})\("([^"]{1,200}")`),
                        Method:  "",
                },
        }

        for lineNum, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)

                // Skip overly long lines
                if len(line) &gt; MaxRegexMatchSize </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip lines that are part of multiline patterns
                <span class="cov8" title="1">if strings.Contains(line, "{") || strings.Contains(line, "}.then") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, p := range simplePatterns </span><span class="cov8" title="1">{
                        matches := p.Pattern.FindStringSubmatch(line)
                        if len(matches) &gt;= 2 </span><span class="cov8" title="1">{
                                path := matches[1]
                                method := p.Method

                                // Extract method from match if available
                                if len(matches) &gt;= 3 &amp;&amp; matches[2] != "" </span><span class="cov8" title="1">{
                                        method = matches[2]
                                }</span>

                                // For axios, method is in group 1
                                <span class="cov8" title="1">if p.Name == "axios" &amp;&amp; len(matches) &gt;= 3 </span><span class="cov8" title="1">{
                                        method = matches[1]
                                        path = matches[2]
                                }</span>

                                <span class="cov8" title="1">calls = append(calls, ExtractedCall{
                                        Path:   path,
                                        Method: strings.ToUpper(method),
                                        File:   filePath,
                                        Line:   lineNum + 1,
                                })
                                break</span>
                        }
                }
        }

        // Deduplicate calls (same path and method)
        <span class="cov8" title="1">uniqueCalls := make(map[string]ExtractedCall)
        for _, call := range calls </span><span class="cov8" title="1">{
                key := call.Path + ":" + call.Method
                uniqueCalls[key] = call
        }</span>

        // Convert map back to slice
        <span class="cov8" title="1">var result []ExtractedCall
        for _, call := range uniqueCalls </span><span class="cov8" title="1">{
                result = append(result, call)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// AnalyzePythonSDK extracts public methods from Python SDK
func (ca *CodeAnalyzer) AnalyzePythonSDK(filePath string) ([]ExtractedMethod, error) <span class="cov8" title="1">{
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read Python file: %w", err)
        }</span>

        // Check file size
        <span class="cov8" title="1">if len(content) &gt; MaxRegexMatchSize*10 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file too large for analysis: %d bytes (max %d)", len(content), MaxRegexMatchSize*10)
        }</span>

        <span class="cov8" title="1">var methods []ExtractedMethod
        lines := strings.Split(string(content), "\n")

        // FIXED: Added length limits to prevent ReDoS
        // Regex for method definition: def method_name(self, ...) -&gt; ReturnType:
        // Handles both def method(self, param) and def method(self, param: type) -&gt; ReturnType:
        methodRe := regexp.MustCompile(`def\s+(\w{1,100})\(self([^)]{0,500})\)(?:\s*-&gt;\s*[^:]{1,100})?:`)
        docsRe := regexp.MustCompile(`"""(.{1,500})"""`)

        for lineNum, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)

                // Skip overly long lines
                if len(line) &gt; MaxRegexMatchSize </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">matches := methodRe.FindStringSubmatch(line)
                if len(matches) &gt;= 2 </span><span class="cov8" title="1">{
                        methodName := matches[1]

                        // Skip private methods
                        if strings.HasPrefix(methodName, "_") </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // Extract parameters
                        <span class="cov8" title="1">paramsStr := matches[2]
                        var parameters []string
                        if paramsStr != "" </span><span class="cov8" title="1">{
                                // Remove leading comma and split
                                paramsStr = strings.TrimPrefix(paramsStr, ",")
                                params := strings.Split(paramsStr, ",")
                                for _, p := range params </span><span class="cov8" title="1">{
                                        p = strings.TrimSpace(p)
                                        if p != "" &amp;&amp; len(p) &lt;= 100 </span><span class="cov8" title="1">{
                                                // Extract parameter name (before type hint)
                                                parts := strings.Fields(p)
                                                if len(parts) &gt; 0 </span><span class="cov8" title="1">{
                                                        parameters = append(parameters, parts[0])
                                                }</span>
                                        }
                                }
                        }

                        // Look for docstring in next few lines
                        <span class="cov8" title="1">description := ""
                        for i := lineNum; i &lt; len(lines) &amp;&amp; i &lt; lineNum+5; i++ </span><span class="cov8" title="1">{
                                docMatches := docsRe.FindStringSubmatch(lines[i])
                                if len(docMatches) &gt;= 2 </span><span class="cov8" title="1">{
                                        description = docMatches[1]
                                        break</span>
                                }
                        }

                        <span class="cov8" title="1">methods = append(methods, ExtractedMethod{
                                Name:        methodName,
                                Parameters:  parameters,
                                ReturnType:  "dict", // Default return type
                                Description: description,
                                File:        filePath,
                                Line:        lineNum + 1,
                        })</span>
                }
        }

        <span class="cov8" title="1">return methods, nil</span>
}

// GenerateOpenAPIContract generates an OpenAPI contract from extracted data
func (ca *CodeAnalyzer) GenerateOpenAPIContract(
        componentName string,
        backendRoutes []ExtractedRoute,
        frontendCalls []ExtractedCall,
) (*OpenAPIContract, error) <span class="cov8" title="1">{
        contract := &amp;OpenAPIContract{
                OpenAPI: "3.0.0",
                Info: InfoSpec{
                        Title:   fmt.Sprintf("%s API", strings.Title(componentName)),
                        Version: "1.0.0",
                },
                Paths: make(PathsSpec),
        }

        // Add backend routes to contract
        for _, route := range backendRoutes </span><span class="cov8" title="1">{
                if _, exists := contract.Paths[route.Path]; !exists </span><span class="cov8" title="1">{
                        contract.Paths[route.Path] = make(PathSpec)
                }</span>

                <span class="cov8" title="1">operation := OperationSpec{
                        Summary: fmt.Sprintf("%s %s", route.Method, route.Path),
                        Responses: ResponsesSpec{
                                "200": ResponseSpec{
                                        Description: "Success",
                                        Content: map[string]MediaSpec{
                                                "application/json": {
                                                        Schema: SchemaRefSpec{Type: "object"},
                                                },
                                        },
                                },
                        },
                }

                // Add request body for POST/PUT/PATCH
                if route.Method == "POST" || route.Method == "PUT" || route.Method == "PATCH" </span><span class="cov8" title="1">{
                        operation.RequestBody = &amp;RequestSpec{
                                Required: true,
                                Content: map[string]MediaSpec{
                                        "application/json": {
                                                Schema: SchemaRefSpec{Type: "object"},
                                        },
                                },
                        }
                }</span>

                <span class="cov8" title="1">contract.Paths[route.Path][strings.ToLower(route.Method)] = operation</span>
        }

        <span class="cov8" title="1">return contract, nil</span>
}

// WriteExtractedContract writes the extracted contract to a YAML file
func (ca *CodeAnalyzer) WriteExtractedContract(contract *OpenAPIContract, outputPath string) error <span class="cov8" title="1">{
        // Ensure directory exists
        dir := filepath.Dir(outputPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Marshal to YAML
        <span class="cov8" title="1">data, err := yaml.Marshal(contract)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal contract: %w", err)
        }</span>

        // Write file
        <span class="cov8" title="1">if err := os.WriteFile(outputPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write contract: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ExtractComponentContract performs end-to-end contract extraction for a component
func (ca *CodeAnalyzer) ExtractComponentContract(
        componentName string,
        componentType string, // "backend", "frontend", "sdk"
        filePaths []string,
        outputPath string,
) error <span class="cov8" title="1">{
        var contract *OpenAPIContract
        var err error

        switch componentType </span>{
        case "backend":<span class="cov8" title="1">
                var allRoutes []ExtractedRoute
                for _, filePath := range filePaths </span><span class="cov8" title="1">{
                        routes, err := ca.AnalyzeGoBackend(filePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to analyze %s: %w", filePath, err)
                        }</span>
                        <span class="cov8" title="1">allRoutes = append(allRoutes, routes...)</span>
                }
                <span class="cov8" title="1">contract, err = ca.GenerateOpenAPIContract(componentName, allRoutes, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate contract: %w", err)
                }</span>

        case "frontend":<span class="cov8" title="1">
                var allCalls []ExtractedCall
                for _, filePath := range filePaths </span><span class="cov8" title="1">{
                        calls, err := ca.AnalyzeTypeScriptFrontend(filePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to analyze %s: %w", filePath, err)
                        }</span>
                        <span class="cov8" title="1">allCalls = append(allCalls, calls...)</span>
                }
                // For frontend, we treat calls as routes
                <span class="cov8" title="1">var routes []ExtractedRoute
                for _, call := range allCalls </span><span class="cov8" title="1">{
                        routes = append(routes, ExtractedRoute{
                                Path:   call.Path,
                                Method: call.Method,
                                File:   call.File,
                                Line:   call.Line,
                        })
                }</span>
                <span class="cov8" title="1">contract, err = ca.GenerateOpenAPIContract(componentName, routes, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate contract: %w", err)
                }</span>

        case "sdk":<span class="cov8" title="1">
                // SDK methods don't map directly to OpenAPI
                // We'll create a minimal contract for now
                contract = &amp;OpenAPIContract{
                        OpenAPI: "3.0.0",
                        Info: InfoSpec{
                                Title:   fmt.Sprintf("%s SDK", strings.Title(componentName)),
                                Version: "1.0.0",
                        },
                        Paths: make(PathsSpec),
                }</span>

        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown component type: %s", componentType)</span>
        }

        // Write contract
        <span class="cov8" title="1">if err := ca.WriteExtractedContract(contract, outputPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write contract: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package agents

import (
        "fmt"
        "regexp"
        "strings"
)

// SchemaInferrer infers request/response schemas from code
type SchemaInferrer struct{}

// ContractGenerator enhances contracts with inferred schemas
type ContractGenerator struct {
        inferrer *SchemaInferrer
}

// NewSchemaInferrer creates a new schema inferrer
func NewSchemaInferrer() *SchemaInferrer <span class="cov8" title="1">{
        return &amp;SchemaInferrer{}
}</span>

// NewContractGenerator creates a new contract generator
func NewContractGenerator() *ContractGenerator <span class="cov8" title="1">{
        return &amp;ContractGenerator{
                inferrer: NewSchemaInferrer(),
        }
}</span>

// InferFromStruct extracts schema from Go struct definition
func (si *SchemaInferrer) InferFromStruct(structName, goCode string) (*SchemaSpec, error) <span class="cov8" title="1">{
        schema := &amp;SchemaSpec{Fields: []FieldSpec{}}

        // Simplified struct parsing - look for struct and extract fields
        lines := strings.Split(goCode, "\n")
        inStruct := false
        structFound := false

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)

                // Find struct definition
                if strings.Contains(line, "type "+structName) &amp;&amp; strings.Contains(line, "struct") </span><span class="cov8" title="1">{
                        inStruct = true
                        structFound = true
                        continue</span>
                }

                // End of struct
                <span class="cov8" title="1">if inStruct &amp;&amp; line == "}" </span><span class="cov8" title="1">{
                        break</span>
                }

                // Extract fields (simplified - just Name Type)
                <span class="cov8" title="1">if inStruct &amp;&amp; !strings.HasPrefix(line, "//") &amp;&amp; line != "" &amp;&amp; !strings.HasPrefix(line, "func") </span><span class="cov8" title="1">{
                        parts := strings.Fields(line)
                        if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                                // Filter out non-field lines
                                if len(parts[0]) &gt; 0 &amp;&amp; parts[0][0] &gt;= 'A' &amp;&amp; parts[0][0] &lt;= 'Z' </span><span class="cov8" title="1">{
                                        fieldName := strings.ToLower(parts[0])
                                        goType := parts[1]

                                        schema.Fields = append(schema.Fields, FieldSpec{
                                                Name:     fieldName,
                                                Type:     mapGoTypeToJSON(goType),
                                                Required: true,
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if !structFound </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("struct %s not found", structName)
        }</span>

        <span class="cov8" title="1">return schema, nil</span>
}

// InferFromHandler extracts schema from handler function
func (si *SchemaInferrer) InferFromHandler(handlerName, goCode string) (*SchemaSpec, error) <span class="cov8" title="1">{
        schema := &amp;SchemaSpec{
                Fields: []FieldSpec{},
        }

        // Find handler function - simplified implementation
        // Full implementation would parse handler body and find struct decode
        if !strings.Contains(goCode, "func "+handlerName) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("handler %s not found", handlerName)
        }</span>

        <span class="cov8" title="1">return schema, nil</span>
}

// InferFromTypeScript extracts schema from TypeScript interface
func (si *SchemaInferrer) InferFromTypeScript(interfaceName, tsCode string) (*SchemaSpec, error) <span class="cov8" title="1">{
        schema := &amp;SchemaSpec{Fields: []FieldSpec{}}

        // Find interface definition
        lines := strings.Split(tsCode, "\n")
        inInterface := false
        interfaceFound := false

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)

                // Find interface definition
                if strings.Contains(line, "interface "+interfaceName) </span><span class="cov8" title="1">{
                        inInterface = true
                        interfaceFound = true
                        continue</span>
                }

                // End of interface
                <span class="cov8" title="1">if inInterface &amp;&amp; line == "}" </span><span class="cov8" title="1">{
                        break</span>
                }

                // Extract fields
                <span class="cov8" title="1">if inInterface &amp;&amp; !strings.HasPrefix(line, "//") &amp;&amp; line != "" </span><span class="cov8" title="1">{
                        // Format: fieldName: type;
                        if strings.Contains(line, ":") &amp;&amp; !strings.Contains(line, "function") </span><span class="cov8" title="1">{
                                parts := strings.Split(line, ":")
                                if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                                        fieldName := strings.TrimSpace(parts[0])
                                        tsType := strings.TrimSpace(parts[1])
                                        tsType = strings.TrimSuffix(tsType, ";")
                                        tsType = strings.TrimSpace(tsType)

                                        schema.Fields = append(schema.Fields, FieldSpec{
                                                Name:     fieldName,
                                                Type:     mapTSTypeToJSON(tsType),
                                                Required: !strings.HasSuffix(tsType, "?"),
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if !interfaceFound </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("interface %s not found", interfaceName)
        }</span>

        <span class="cov8" title="1">return schema, nil</span>
}

// GenerateFromBackend generates a complete contract from backend routes
func (cg *ContractGenerator) GenerateFromBackend(
        componentName string,
        routes []ExtractedRoute,
) (*OpenAPIContract, error) <span class="cov8" title="1">{
        contract := &amp;OpenAPIContract{
                OpenAPI: "3.0.0",
                Info: InfoSpec{
                        Title:   fmt.Sprintf("%s API", strings.Title(componentName)),
                        Version: "1.0.0",
                },
                Paths: make(PathsSpec),
        }

        for _, route := range routes </span><span class="cov8" title="1">{
                if _, exists := contract.Paths[route.Path]; !exists </span><span class="cov8" title="1">{
                        contract.Paths[route.Path] = make(PathSpec)
                }</span>

                <span class="cov8" title="1">operation := OperationSpec{
                        Summary: fmt.Sprintf("%s %s", route.Method, route.Path),
                        Responses: ResponsesSpec{
                                "200": ResponseSpec{
                                        Description: "Success",
                                        Content: map[string]MediaSpec{
                                                "application/json": {
                                                        Schema: SchemaRefSpec{
                                                                Type:       "object",
                                                                Properties: map[string]PropertySpec{},
                                                        },
                                                },
                                        },
                                },
                        },
                }

                // Add request body for POST/PUT/PATCH
                if route.Method == "POST" || route.Method == "PUT" || route.Method == "PATCH" </span><span class="cov8" title="1">{
                        operation.RequestBody = &amp;RequestSpec{
                                Required: true,
                                Content: map[string]MediaSpec{
                                        "application/json": {
                                                Schema: SchemaRefSpec{
                                                        Type:       "object",
                                                        Properties: map[string]PropertySpec{},
                                                },
                                        },
                                },
                        }
                }</span>

                <span class="cov8" title="1">contract.Paths[route.Path][strings.ToLower(route.Method)] = operation</span>
        }

        <span class="cov8" title="1">return contract, nil</span>
}

// EnhanceContract enhances a contract with inferred schemas
func (cg *ContractGenerator) EnhanceContract(
        contract *OpenAPIContract,
        inferredSchemas map[string]SchemaSpec,
) (*OpenAPIContract, error) <span class="cov8" title="1">{
        // Create a copy to avoid mutating the original
        enhanced := &amp;OpenAPIContract{
                OpenAPI: contract.OpenAPI,
                Info:    contract.Info,
                Paths:   make(PathsSpec),
        }

        // Copy paths and enhance schemas
        for path, pathSpec := range contract.Paths </span><span class="cov8" title="1">{
                enhanced.Paths[path] = make(PathSpec)

                for method, operation := range pathSpec </span><span class="cov8" title="1">{
                        enhancedOp := operation

                        // Enhance request schema - recreate request body
                        if operation.RequestBody != nil </span><span class="cov8" title="1">{
                                schemaKey := fmt.Sprintf("%s:%s:request", path, method)
                                if schema, ok := inferredSchemas[schemaKey]; ok </span><span class="cov8" title="1">{
                                        newContent := make(map[string]MediaSpec)
                                        for mediaType := range operation.RequestBody.Content </span><span class="cov8" title="1">{
                                                newContent[mediaType] = MediaSpec{
                                                        Schema: cg.schemaSpecToSchemaRef(schema),
                                                }
                                        }</span>
                                        <span class="cov8" title="1">enhancedOp.RequestBody = &amp;RequestSpec{
                                                Required: operation.RequestBody.Required,
                                                Content:  newContent,
                                        }</span>
                                }
                        }

                        // Enhance response schemas - recreate responses
                        <span class="cov8" title="1">newResponses := make(ResponsesSpec)
                        for statusCode, response := range operation.Responses </span><span class="cov8" title="1">{
                                schemaKey := fmt.Sprintf("%s:%s:response:%s", path, method, statusCode)
                                if schema, ok := inferredSchemas[schemaKey]; ok </span><span class="cov0" title="0">{
                                        newContent := make(map[string]MediaSpec)
                                        for mediaType := range response.Content </span><span class="cov0" title="0">{
                                                newContent[mediaType] = MediaSpec{
                                                        Schema: cg.schemaSpecToSchemaRef(schema),
                                                }
                                        }</span>
                                        <span class="cov0" title="0">newResponses[statusCode] = ResponseSpec{
                                                Description: response.Description,
                                                Content:     newContent,
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        newResponses[statusCode] = response
                                }</span>
                        }
                        <span class="cov8" title="1">enhancedOp.Responses = newResponses

                        enhanced.Paths[path][method] = enhancedOp</span>
                }
        }

        <span class="cov8" title="1">return enhanced, nil</span>
}

// schemaSpecToSchemaRef converts a SchemaSpec to SchemaRefSpec
func (cg *ContractGenerator) schemaSpecToSchemaRef(schema SchemaSpec) SchemaRefSpec <span class="cov8" title="1">{
        properties := make(map[string]PropertySpec)
        required := []string{}

        for _, field := range schema.Fields </span><span class="cov8" title="1">{
                properties[field.Name] = PropertySpec{Type: field.Type}
                if field.Required </span><span class="cov8" title="1">{
                        required = append(required, field.Name)
                }</span>
        }

        <span class="cov8" title="1">return SchemaRefSpec{
                Type:       "object",
                Properties: properties,
                Required:   required,
        }</span>
}

// Helper functions

// mapGoTypeToJSON maps Go types to JSON types
func mapGoTypeToJSON(goType string) string <span class="cov8" title="1">{
        switch goType </span>{
        case "string":<span class="cov8" title="1">
                return "string"</span>
        case "int", "int32", "int64", "uint32", "uint64":<span class="cov0" title="0">
                return "integer"</span>
        case "float32", "float64":<span class="cov0" title="0">
                return "number"</span>
        case "bool":<span class="cov0" title="0">
                return "boolean"</span>
        default:<span class="cov8" title="1">
                if strings.HasPrefix(goType, "[]") </span><span class="cov0" title="0">{
                        return "array"
                }</span>
                <span class="cov8" title="1">if strings.HasPrefix(goType, "map[") </span><span class="cov8" title="1">{
                        return "object"
                }</span>
                <span class="cov0" title="0">return "object"</span>
        }
}

// mapTSTypeToJSON maps TypeScript types to JSON types
func mapTSTypeToJSON(tsType string) string <span class="cov8" title="1">{
        // Remove optional marker
        tsType = strings.TrimSuffix(tsType, "?")
        tsType = strings.TrimSpace(tsType)

        switch tsType </span>{
        case "string":<span class="cov8" title="1">
                return "string"</span>
        case "number":<span class="cov0" title="0">
                return "number"</span>
        case "boolean":<span class="cov0" title="0">
                return "boolean"</span>
        default:<span class="cov0" title="0">
                if strings.HasPrefix(tsType, "Array&lt;") </span><span class="cov0" title="0">{
                        return "array"
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(tsType, "Record&lt;") </span><span class="cov0" title="0">{
                        return "object"
                }</span>
                <span class="cov0" title="0">return "object"</span>
        }
}

// FindSchemaInCode finds and infers schema from code snippet
func (si *SchemaInferrer) FindSchemaInCode(codeSnippet, language, typeName string) (*SchemaSpec, error) <span class="cov8" title="1">{
        switch language </span>{
        case "go":<span class="cov8" title="1">
                return si.InferFromStruct(typeName, codeSnippet)</span>
        case "typescript", "javascript":<span class="cov8" title="1">
                return si.InferFromTypeScript(typeName, codeSnippet)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported language: %s", language)</span>
        }
}

// ParseSchemaFromComment extracts schema from docstring comments
func (si *SchemaInferrer) ParseSchemaFromComment(comment string) (*SchemaSpec, error) <span class="cov8" title="1">{
        schema := &amp;SchemaSpec{Fields: []FieldSpec{}}

        // Parse comment lines for schema hints
        // Format: @param field_name type description
        lines := strings.Split(comment, "\n")
        paramRe := regexp.MustCompile(`@param\s+(\w+)\s+(\w+)`)

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                matches := paramRe.FindStringSubmatch(line)
                if len(matches) &gt;= 3 </span><span class="cov8" title="1">{
                        schema.Fields = append(schema.Fields, FieldSpec{
                                Name:     matches[1],
                                Type:     matches[2],
                                Required: true,
                        })
                }</span>
        }

        <span class="cov8" title="1">return schema, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package agents

import (
        "bytes"
        "context"
        "fmt"
        "os"
        "sort"
        "strings"
        "time"

        "gopkg.in/yaml.v3"
)

const (
        // MaxYAMLFileSize is the maximum allowed YAML file size (10MB)
        MaxYAMLFileSize = 10 * 1024 * 1024
        // YAMLParseTimeout is the maximum time allowed for YAML parsing
        YAMLParseTimeout = 30 * time.Second
)

// safeYAMLUnmarshal safely unmarshals YAML with security controls
// Prevents billion laughs attack and other DoS vectors
func safeYAMLUnmarshal(data []byte, v interface{}) error <span class="cov8" title="1">{
        // 1. Check file size limit
        if len(data) &gt; MaxYAMLFileSize </span><span class="cov8" title="1">{
                return fmt.Errorf("YAML file size %d bytes exceeds maximum allowed size %d bytes", len(data), MaxYAMLFileSize)
        }</span>

        // 2. Create context with timeout
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), YAMLParseTimeout)
        defer cancel()

        // 3. Use decoder with strict mode (known fields only)
        decoder := yaml.NewDecoder(bytes.NewReader(data))
        decoder.KnownFields(true)

        // 4. Unmarshal with timeout
        done := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                done &lt;- decoder.Decode(v)
        }</span>()

        <span class="cov8" title="1">select </span>{
        case err := &lt;-done:<span class="cov8" title="1">
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("YAML parse error: %w", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("YAML parsing timeout after %v", YAMLParseTimeout)</span>
        }
}

// ContractMismatch represents a detected contract mismatch
type ContractMismatch struct {
        Severity   string `yaml:"severity"`   // ERROR, WARNING, INFO
        Type       string `yaml:"type"`       // endpoint_mismatch, schema_incompatibility
        ComponentA string `yaml:"component_a"` // e.g., "frontend"
        ComponentB string `yaml:"component_b"` // e.g., "backend"
        Path       string `yaml:"path"`        // API path
        Method     string `yaml:"method"`      // HTTP method
        Expected   string `yaml:"expected"`    // What was expected
        Actual     string `yaml:"actual"`      // What was found
        File       string `yaml:"file"`        // File location
        Fix        string `yaml:"fix"`         // Suggested fix
}

// ContractValidator validates contracts against each other
type ContractValidator struct{}

// NewContractValidator creates a new contract validator
func NewContractValidator() *ContractValidator <span class="cov8" title="1">{
        return &amp;ContractValidator{}
}</span>

// CompareContracts compares two contracts and returns mismatches
func (cv *ContractValidator) CompareContracts(
        contractA, contractB *OpenAPIContract,
        nameA, nameB string,
) ([]*ContractMismatch, error) <span class="cov8" title="1">{
        var mismatches []*ContractMismatch

        // Collect all paths from both contracts
        pathsA := cv.extractPaths(contractA)
        pathsB := cv.extractPaths(contractB)

        // Check for paths in A but not in B
        for path, methodsA := range pathsA </span><span class="cov8" title="1">{
                methodsB, existsB := pathsB[path]

                if !existsB </span><span class="cov8" title="1">{
                        // Path not in B
                        for method := range methodsA </span><span class="cov8" title="1">{
                                mismatches = append(mismatches, &amp;ContractMismatch{
                                        Severity:   "ERROR",
                                        Type:       "endpoint_mismatch",
                                        ComponentA: nameA,
                                        ComponentB: nameB,
                                        Path:       path,
                                        Method:     method,
                                        Expected:   fmt.Sprintf("%s %s", strings.ToUpper(method), path),
                                        Actual:     "NOT FOUND",
                                        Fix:        fmt.Sprintf("Add endpoint to %s", nameB),
                                })
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // Check methods
                <span class="cov8" title="1">for method := range methodsA </span><span class="cov8" title="1">{
                        if _, existsMethod := methodsB[method]; !existsMethod </span><span class="cov8" title="1">{
                                mismatches = append(mismatches, &amp;ContractMismatch{
                                        Severity:   "ERROR",
                                        Type:       "endpoint_mismatch",
                                        ComponentA: nameA,
                                        ComponentB: nameB,
                                        Path:       path,
                                        Method:     method,
                                        Expected:   fmt.Sprintf("%s %s", strings.ToUpper(method), path),
                                        Actual:     "METHOD NOT FOUND",
                                        Fix:        fmt.Sprintf("Add %s method to %s", strings.ToUpper(method), nameB),
                                })
                        }</span>
                }
        }

        // Check for paths in B but not in A
        <span class="cov8" title="1">for path := range pathsB </span><span class="cov8" title="1">{
                if _, existsA := pathsA[path]; !existsA </span><span class="cov8" title="1">{
                        for method := range pathsB[path] </span><span class="cov8" title="1">{
                                mismatches = append(mismatches, &amp;ContractMismatch{
                                        Severity:   "WARNING",
                                        Type:       "endpoint_mismatch",
                                        ComponentA: nameB,
                                        ComponentB: nameA,
                                        Path:       path,
                                        Method:     method,
                                        Expected:   "NOT USED",
                                        Actual:     fmt.Sprintf("%s %s", strings.ToUpper(method), path),
                                        Fix:        fmt.Sprintf("Use this endpoint in %s or remove from %s", nameA, nameB),
                                })
                        }</span>
                }
        }

        <span class="cov8" title="1">return mismatches, nil</span>
}

// ValidateSchemas validates schema compatibility
func (cv *ContractValidator) ValidateSchemas(
        schemaA, schemaB SchemaRefSpec,
        path, nameA, nameB string,
) *ContractMismatch <span class="cov8" title="1">{
        // Check required fields in A exist in B
        for _, requiredField := range schemaA.Required </span><span class="cov8" title="1">{
                if _, existsB := schemaB.Properties[requiredField]; !existsB </span><span class="cov8" title="1">{
                        return &amp;ContractMismatch{
                                Severity:   "WARNING",
                                Type:       "schema_incompatibility",
                                ComponentA: nameA,
                                ComponentB: nameB,
                                Path:       path,
                                Expected:   fmt.Sprintf("Field '%s' required by %s", requiredField, nameA),
                                Actual:     fmt.Sprintf("Field '%s' not found in %s", requiredField, nameB),
                                Fix:        fmt.Sprintf("Add field '%s' to %s or mark optional in %s", requiredField, nameB, nameA),
                        }
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateFrontendBackend validates frontend vs backend contracts
func (cv *ContractValidator) ValidateFrontendBackend(
        frontend, backend *OpenAPIContract,
) ([]*ContractMismatch, error) <span class="cov8" title="1">{
        mismatches, err := cv.CompareContracts(frontend, backend, "frontend", "backend")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check schema compatibility for matching endpoints
        <span class="cov8" title="1">for path, frontendPath := range frontend.Paths </span><span class="cov8" title="1">{
                if backendPath, exists := backend.Paths[path]; exists </span><span class="cov8" title="1">{
                        for method, frontendOp := range frontendPath </span><span class="cov8" title="1">{
                                if backendOp, existsMethod := backendPath[method]; existsMethod </span><span class="cov8" title="1">{
                                        // Both have this endpoint - check schemas
                                        if frontendOp.RequestBody != nil &amp;&amp; backendOp.RequestBody != nil </span><span class="cov8" title="1">{
                                                for mediaType := range frontendOp.RequestBody.Content </span><span class="cov8" title="1">{
                                                        if backendSchema, existsBackend := backendOp.RequestBody.Content[mediaType]; existsBackend </span><span class="cov8" title="1">{
                                                                mismatch := cv.ValidateSchemas(
                                                                        frontendOp.RequestBody.Content[mediaType].Schema,
                                                                        backendSchema.Schema,
                                                                        path,
                                                                        "frontend",
                                                                        "backend",
                                                                )
                                                                if mismatch != nil </span><span class="cov8" title="1">{
                                                                        mismatches = append(mismatches, mismatch)
                                                                }</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return mismatches, nil</span>
}

// ValidateSDKBackend validates SDK vs backend contracts
func (cv *ContractValidator) ValidateSDKBackend(
        sdk, backend *OpenAPIContract,
) ([]*ContractMismatch, error) <span class="cov8" title="1">{
        // Similar to frontend-backend validation
        return cv.CompareContracts(sdk, backend, "sdk", "backend")
}</span>

// GenerateReport generates a markdown validation report
func (cv *ContractValidator) GenerateReport(mismatches []*ContractMismatch) string <span class="cov8" title="1">{
        var sb strings.Builder

        sb.WriteString("# Contract Validation Report\n\n")

        // Sort by severity and type
        sort.Slice(mismatches, func(i, j int) bool </span><span class="cov0" title="0">{
                if mismatches[i].Severity != mismatches[j].Severity </span><span class="cov0" title="0">{
                        return mismatches[i].Severity &gt; mismatches[j].Severity
                }</span>
                <span class="cov0" title="0">return mismatches[i].Type &lt; mismatches[j].Type</span>
        })

        // Count by severity
        <span class="cov8" title="1">errorCount := 0
        warningCount := 0
        infoCount := 0

        for _, m := range mismatches </span><span class="cov8" title="1">{
                switch m.Severity </span>{
                case "ERROR":<span class="cov8" title="1">
                        errorCount++</span>
                case "WARNING":<span class="cov0" title="0">
                        warningCount++</span>
                case "INFO":<span class="cov0" title="0">
                        infoCount++</span>
                }
        }

        <span class="cov8" title="1">sb.WriteString("## Summary\n\n")
        sb.WriteString(fmt.Sprintf("- Total issues: %d\n", len(mismatches)))
        sb.WriteString(fmt.Sprintf("- Errors: %d\n", errorCount))
        sb.WriteString(fmt.Sprintf("- Warnings: %d\n", warningCount))
        sb.WriteString(fmt.Sprintf("- Info: %d\n\n", infoCount))

        // Errors section
        if errorCount &gt; 0 </span><span class="cov8" title="1">{
                sb.WriteString("## Errors\n\n")
                cv.writeMismatchesTable(&amp;sb, mismatches, "ERROR")
        }</span>

        // Warnings section
        <span class="cov8" title="1">if warningCount &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("## Warnings\n\n")
                cv.writeMismatchesTable(&amp;sb, mismatches, "WARNING")
        }</span>

        // Info section
        <span class="cov8" title="1">if infoCount &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("## Info\n\n")
                cv.writeMismatchesTable(&amp;sb, mismatches, "INFO")
        }</span>

        <span class="cov8" title="1">if len(mismatches) == 0 </span><span class="cov0" title="0">{
                sb.WriteString(" No contract mismatches found!\n")
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

// writeMismatchesTable writes a markdown table for mismatches of given severity
func (cv *ContractValidator) writeMismatchesTable(sb *strings.Builder, mismatches []*ContractMismatch, severity string) <span class="cov8" title="1">{
        sb.WriteString("| Component | Type | Expected | Actual | Fix |\n")
        sb.WriteString("|-----------|------|----------|--------|-----|\n")

        for _, m := range mismatches </span><span class="cov8" title="1">{
                if m.Severity != severity </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">component := fmt.Sprintf("%s vs %s", m.ComponentA, m.ComponentB)
                sb.WriteString(fmt.Sprintf("| %s | %s | %s | %s | %s |\n",
                        component, m.Type, m.Expected, m.Actual, m.Fix))</span>
        }

        <span class="cov8" title="1">sb.WriteString("\n")</span>
}

// WriteReport writes the validation report to a file
func (cv *ContractValidator) WriteReport(report, outputPath string) error <span class="cov8" title="1">{
        // Ensure directory exists
        dir := outputPath[:strings.LastIndex(outputPath, "/")]
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Write file
        <span class="cov8" title="1">if err := os.WriteFile(outputPath, []byte(report), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write report: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// extractPaths extracts all paths and methods from a contract
func (cv *ContractValidator) extractPaths(contract *OpenAPIContract) map[string]map[string]bool <span class="cov8" title="1">{
        paths := make(map[string]map[string]bool)

        for path, pathSpec := range contract.Paths </span><span class="cov8" title="1">{
                paths[path] = make(map[string]bool)
                for method := range pathSpec </span><span class="cov8" title="1">{
                        paths[path][method] = true
                }</span>
        }

        <span class="cov8" title="1">return paths</span>
}

// ValidateContractFile validates a contract file and returns issues
func (cv *ContractValidator) ValidateContractFile(contractPath string) ([]*ContractMismatch, error) <span class="cov8" title="1">{
        // Read contract file
        content, err := os.ReadFile(contractPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read contract: %w", err)
        }</span>

        // Parse YAML with security controls
        <span class="cov8" title="1">contract := &amp;OpenAPIContract{}
        if err := safeYAMLUnmarshal(content, contract); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse contract: %w", err)
        }</span>

        // Validate contract structure
        <span class="cov8" title="1">var mismatches []*ContractMismatch

        // Check required fields
        if contract.OpenAPI == "" </span><span class="cov8" title="1">{
                mismatches = append(mismatches, &amp;ContractMismatch{
                        Severity: "ERROR",
                        Type:     "invalid_contract",
                        Expected: "openapi version",
                        Actual:   "missing",
                        Fix:      "Add openapi: 3.0.0 to contract",
                })
        }</span>

        <span class="cov8" title="1">if len(contract.Paths) == 0 </span><span class="cov8" title="1">{
                mismatches = append(mismatches, &amp;ContractMismatch{
                        Severity: "WARNING",
                        Type:     "invalid_contract",
                        Expected: "at least one path",
                        Actual:   "no paths defined",
                        Fix:      "Add API paths to contract",
                })
        }</span>

        <span class="cov8" title="1">return mismatches, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package agents

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/fall-out-bug/sdp/src/sdp/synthesis"
        "gopkg.in/yaml.v3"
)

// ContractSynthesizer manages contract synthesis from requirements
type ContractSynthesizer struct {
        supervisor *synthesis.Supervisor
}

// ContractRequirements represents parsed feature requirements
type ContractRequirements struct {
        FeatureName string         `yaml:"feature_name"`
        Endpoints   []EndpointSpec `yaml:"endpoints"`
}

// EndpointSpec represents an API endpoint specification
type EndpointSpec struct {
        Path     string     `yaml:"path"`
        Method   string     `yaml:"method"`
        Request  SchemaSpec `yaml:"request"`
        Response SchemaSpec `yaml:"response"`
}

// SchemaSpec represents a request/response schema
type SchemaSpec struct {
        Fields []FieldSpec `yaml:"fields"`
}

// FieldSpec represents a field in a schema
type FieldSpec struct {
        Name     string `yaml:"name"`
        Type     string `yaml:"type"`
        Required bool   `yaml:"required"`
}

// OpenAPIContract represents an OpenAPI 3.0 contract
type OpenAPIContract struct {
        OpenAPI string     `yaml:"openapi"`
        Info    InfoSpec   `yaml:"info"`
        Paths   PathsSpec  `yaml:"paths"`
}

// InfoSpec represents OpenAPI info block
type InfoSpec struct {
        Title   string `yaml:"title"`
        Version string `yaml:"version"`
}

// PathsSpec represents OpenAPI paths block
type PathsSpec map[string]PathSpec

// PathSpec represents a single path in OpenAPI
type PathSpec map[string]OperationSpec

// OperationSpec represents an HTTP operation in OpenAPI
type OperationSpec struct {
        Summary    string      `yaml:"summary"`
        RequestBody   *RequestSpec  `yaml:"requestBody,omitempty"`
        Responses ResponsesSpec `yaml:"responses"`
}

// RequestSpec represents OpenAPI request body
type RequestSpec struct {
        Required bool                 `yaml:"required"`
        Content  map[string]MediaSpec `yaml:"content"`
}

// ResponsesSpec represents OpenAPI responses
type ResponsesSpec map[string]ResponseSpec

// ResponseSpec represents an OpenAPI response
type ResponseSpec struct {
        Description string                 `yaml:"description"`
        Content     map[string]MediaSpec   `yaml:"content"`
}

// MediaSpec represents OpenAPI media type
type MediaSpec struct {
        Schema SchemaRefSpec `yaml:"schema"`
}

// SchemaRefSpec represents OpenAPI schema reference
type SchemaRefSpec struct {
        Type       string                    `yaml:"type,omitempty"`
        Properties map[string]PropertySpec   `yaml:"properties,omitempty"`
        Required   []string                  `yaml:"required,omitempty"`
}

// PropertySpec represents a property in schema
type PropertySpec struct {
        Type string `yaml:"type"`
}

// EndpointProposal represents a proposed endpoint change
type EndpointProposal struct {
        Path   string
        Method string
}

// NewContractSynthesizer creates a new contract synthesizer
func NewContractSynthesizer() *ContractSynthesizer <span class="cov8" title="1">{
        engine := synthesis.DefaultRuleEngine()
        supervisor := synthesis.NewSupervisor(engine, 3) // max 3 agents

        return &amp;ContractSynthesizer{
                supervisor: supervisor,
        }
}</span>

// AnalyzeRequirements parses a requirements markdown file
func (cs *ContractSynthesizer) AnalyzeRequirements(reqPath string) (*ContractRequirements, error) <span class="cov8" title="1">{
        // Read requirements file
        content, err := os.ReadFile(reqPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read requirements: %w", err)
        }</span>

        // Extract feature name from filename
        <span class="cov8" title="1">featureName := strings.TrimSuffix(filepath.Base(reqPath), "-requirements.md")
        featureName = strings.TrimPrefix(featureName, "sdp-")

        // Validate feature name to prevent injection attacks
        if err := validateFeatureName(featureName); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid feature name in path %q: %w", reqPath, err)
        }</span>

        // Parse endpoints from markdown
        <span class="cov8" title="1">endpoints, err := cs.parseEndpointsFromMarkdown(string(content))
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse endpoints: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ContractRequirements{
                FeatureName: featureName,
                Endpoints:   endpoints,
        }, nil</span>
}

const (
        // MaxContentLength limits content size to prevent ReDoS
        MaxContentLength = 100000
        // MaxFieldCount limits number of fields to prevent resource exhaustion
        MaxFieldCount = 100
)

var (
        // allowedHTTPMethods is a whitelist of permitted HTTP methods
        allowedHTTPMethods = map[string]bool{
                "GET":     true,
                "POST":    true,
                "PUT":     true,
                "DELETE":  true,
                "PATCH":   true,
                "HEAD":    true,
                "OPTIONS": true,
        }
)

// validateFeatureName checks if a feature name is valid
func validateFeatureName(name string) error <span class="cov8" title="1">{
        // Feature names must be lowercase alphanumeric with dashes only
        // This prevents injection attacks via malicious feature names
        matched, err := regexp.MatchString(`^[a-z0-9-]+$`, name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("feature name validation failed: %w", err)
        }</span>
        <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid feature name %q: must contain only lowercase letters, numbers, and dashes", name)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateHTTPMethod checks if an HTTP method is allowed
func validateHTTPMethod(method string) error <span class="cov8" title="1">{
        // Method must contain only uppercase letters (no special characters, no spaces)
        if !regexp.MustCompile(`^[A-Z]+$`).MatchString(method) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid HTTP method %q: must contain only uppercase letters", method)
        }</span>

        // Normalize to uppercase for whitelist check
        <span class="cov8" title="1">normalizedMethod := strings.ToUpper(method)
        if !allowedHTTPMethods[normalizedMethod] </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid HTTP method %q: must be one of %v", method, getAllowedMethods())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// getAllowedMethods returns the list of allowed HTTP methods
func getAllowedMethods() []string <span class="cov8" title="1">{
        methods := make([]string, 0, len(allowedHTTPMethods))
        for method := range allowedHTTPMethods </span><span class="cov8" title="1">{
                methods = append(methods, method)
        }</span>
        <span class="cov8" title="1">return methods</span>
}

// validateEndpointPath checks if an endpoint path is valid
func validateEndpointPath(path string) error <span class="cov8" title="1">{
        // Paths must start with /
        if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid endpoint path %q: must start with /", path)
        }</span>

        // Paths should not contain .. to prevent directory traversal
        <span class="cov8" title="1">if strings.Contains(path, "..") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid endpoint path %q: must not contain ..", path)
        }</span>

        // Limit path length to prevent DoS
        <span class="cov8" title="1">if len(path) &gt; 500 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid endpoint path %q: too long (max 500 chars)", path)
        }</span>

        // Paths should only contain safe characters
        // Allow: /, alphanumeric, -, _, :, {}, * (for path params and wildcards)
        <span class="cov8" title="1">matched, err := regexp.MatchString(`^/[a-zA-Z0-9\-_{}/*.:]+$`, path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("endpoint path validation failed: %w", err)
        }</span>
        <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid endpoint path %q: contains invalid characters", path)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// sanitizeFieldName sanitizes field names to prevent injection
func sanitizeFieldName(name string) (string, error) <span class="cov8" title="1">{
        // Field names must be alphanumeric with underscores
        matched, err := regexp.MatchString(`^[a-zA-Z_][a-zA-Z0-9_]*$`, name)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field name validation failed: %w", err)
        }</span>
        <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid field name %q: must be alphanumeric with underscores, starting with letter or underscore", name)
        }</span>
        <span class="cov8" title="1">return name, nil</span>
}

// parseEndpointsFromMarkdown extracts endpoint specifications from markdown
func (cs *ContractSynthesizer) parseEndpointsFromMarkdown(content string) ([]EndpointSpec, error) <span class="cov8" title="1">{
        var endpoints []EndpointSpec

        // Check content size before processing
        if len(content) &gt; MaxContentLength </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("content too large for parsing: %d bytes (max %d)", len(content), MaxContentLength)
        }</span>

        // FIXED: Added length limits to prevent ReDoS attacks
        // Regex to match endpoint headers: ### POST /api/v1/telemetry/events or - POST /api/v1/telemetry/events
        // Limit path length to 500 chars to prevent catastrophic backtracking
        // Capture method as non-slash, non-space characters on the same line
        // Use [^/\s]+ to ensure we only capture word-like characters
        <span class="cov8" title="1">endpointRe := regexp.MustCompile(`(?:###|-)\s+([^/\s]{1,20})\s+(/[^\s]{1,500})`)
        matches := endpointRe.FindAllStringSubmatch(content, -1)

        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Validate HTTP method (whitelist check) and normalize to uppercase
                // match[1] is the raw method string from the regex
                <span class="cov8" title="1">rawMethod := match[1]
                method := strings.ToUpper(rawMethod)

                // Strict validation: the raw method must be exactly the same as the uppercased version
                // This prevents "GET; DROP TABLE users" from being accepted as "GET"
                if rawMethod != method </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid HTTP method %q: must be uppercase only, got mixed case or special characters", rawMethod)
                }</span>

                <span class="cov8" title="1">if err := validateHTTPMethod(method); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid HTTP method in endpoint: %w", err)
                }</span>

                // Validate endpoint path format
                <span class="cov8" title="1">path := match[2]
                if err := validateEndpointPath(path); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid endpoint path: %w", err)
                }</span>

                <span class="cov8" title="1">endpoint := EndpointSpec{
                        Path:   path,
                        Method: method,
                        Request:  SchemaSpec{Fields: []FieldSpec{}},
                        Response: SchemaSpec{Fields: []FieldSpec{}},
                }

                // Extract request/response fields from markdown lists
                // Format: - Request: {field1, field2} or - field_name: type
                lines := strings.Split(content, "\n")
                inRequestSection := false
                inResponseSection := false

                for _, line := range lines </span><span class="cov8" title="1">{
                        line = strings.TrimSpace(line)

                        if strings.Contains(line, fmt.Sprintf("### %s", match[1])) </span><span class="cov8" title="1">{
                                // Start of this endpoint's section
                                inRequestSection = false
                                inResponseSection = false
                                continue</span>
                        }

                        <span class="cov8" title="1">if strings.Contains(line, "Request:") &amp;&amp; strings.Contains(content, line) </span><span class="cov8" title="1">{
                                inRequestSection = true
                                inResponseSection = false

                                // FIXED: Limited field content to 500 chars to prevent ReDoS
                                // Parse inline field specification: {field1, field2}
                                inlineRe := regexp.MustCompile(`Request:\s*\{([^}]{1,500})\}`)
                                if inlineMatches := inlineRe.FindStringSubmatch(line); len(inlineMatches) &gt; 1 </span><span class="cov8" title="1">{
                                        fields := strings.Split(inlineMatches[1], ",")
                                        for _, f := range fields </span><span class="cov8" title="1">{
                                                f = strings.TrimSpace(f)
                                                if f != "" </span><span class="cov8" title="1">{
                                                        // Sanitize field name to prevent injection
                                                        sanitized, err := sanitizeFieldName(f)
                                                        if err != nil </span><span class="cov8" title="1">{
                                                                return nil, fmt.Errorf("invalid request field name: %w", err)
                                                        }</span>
                                                        <span class="cov8" title="1">endpoint.Request.Fields = append(endpoint.Request.Fields, FieldSpec{
                                                                Name:     sanitized,
                                                                Type:     "string",
                                                                Required: true,
                                                        })</span>
                                                }
                                        }
                                }
                                <span class="cov8" title="1">continue</span>
                        }

                        <span class="cov8" title="1">if strings.Contains(line, "Response:") </span><span class="cov8" title="1">{
                                inRequestSection = false
                                inResponseSection = true

                                // FIXED: Limited field content to 500 chars to prevent ReDoS
                                // Parse inline field specification
                                inlineRe := regexp.MustCompile(`Response:\s*\{([^}]{1,500})\}`)
                                if inlineMatches := inlineRe.FindStringSubmatch(line); len(inlineMatches) &gt; 1 </span><span class="cov8" title="1">{
                                        fields := strings.Split(inlineMatches[1], ",")
                                        for _, f := range fields </span><span class="cov8" title="1">{
                                                f = strings.TrimSpace(f)
                                                if f != "" </span><span class="cov8" title="1">{
                                                        // Sanitize field name to prevent injection
                                                        sanitized, err := sanitizeFieldName(f)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return nil, fmt.Errorf("invalid response field name: %w", err)
                                                        }</span>
                                                        <span class="cov8" title="1">endpoint.Response.Fields = append(endpoint.Response.Fields, FieldSpec{
                                                                Name:     sanitized,
                                                                Type:     "string",
                                                                Required: true,
                                                        })</span>
                                                }
                                        }
                                }
                                <span class="cov8" title="1">continue</span>
                        }

                        // Parse bullet point fields: - field_name: type
                        <span class="cov8" title="1">if strings.HasPrefix(line, "-") </span><span class="cov8" title="1">{
                                // FIXED: Added length limits to prevent ReDoS
                                fieldRe := regexp.MustCompile(`-\s*(\w{1,100}):\s*(\w{1,50})`)
                                if fieldMatches := fieldRe.FindStringSubmatch(line); len(fieldMatches) &gt; 2 </span><span class="cov0" title="0">{
                                        // Enforce field count limit
                                        if len(endpoint.Request.Fields) &gt;= MaxFieldCount || len(endpoint.Response.Fields) &gt;= MaxFieldCount </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("too many fields (max %d)", MaxFieldCount)
                                        }</span>

                                        // Sanitize field name
                                        <span class="cov0" title="0">fieldName := fieldMatches[1]
                                        sanitizedName, err := sanitizeFieldName(fieldName)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("invalid field name in bullet point: %w", err)
                                        }</span>

                                        <span class="cov0" title="0">field := FieldSpec{
                                                Name: sanitizedName,
                                                Type: fieldMatches[2],
                                        }

                                        if inRequestSection </span><span class="cov0" title="0">{
                                                endpoint.Request.Fields = append(endpoint.Request.Fields, field)
                                        }</span> else<span class="cov0" title="0"> if inResponseSection </span><span class="cov0" title="0">{
                                                endpoint.Response.Fields = append(endpoint.Response.Fields, field)
                                        }</span>
                                }
                        }
                }

                <span class="cov8" title="1">endpoints = append(endpoints, endpoint)</span>
        }

        <span class="cov8" title="1">return endpoints, nil</span>
}

// ProposeContract generates an initial OpenAPI contract from requirements
func (cs *ContractSynthesizer) ProposeContract(requirements *ContractRequirements) (*OpenAPIContract, error) <span class="cov8" title="1">{
        contract := &amp;OpenAPIContract{
                OpenAPI: "3.0.0",
                Info: InfoSpec{
                        Title:   fmt.Sprintf("%s API", strings.Title(requirements.FeatureName)),
                        Version: "1.0.0",
                },
                Paths: make(PathsSpec),
        }

        // Convert endpoints to OpenAPI paths
        for _, endpoint := range requirements.Endpoints </span><span class="cov8" title="1">{
                path := cs.endpointToPathSpec(endpoint)
                contract.Paths[endpoint.Path] = path
        }</span>

        <span class="cov8" title="1">return contract, nil</span>
}

// endpointToPathSpec converts an endpoint spec to OpenAPI path spec
func (cs *ContractSynthesizer) endpointToPathSpec(endpoint EndpointSpec) PathSpec <span class="cov8" title="1">{
        pathSpec := make(PathSpec)

        operation := OperationSpec{
                Summary: fmt.Sprintf("%s %s", endpoint.Method, endpoint.Path),
                Responses: ResponsesSpec{
                        "200": ResponseSpec{
                                Description: "Success",
                                Content: map[string]MediaSpec{
                                        "application/json": {
                                                Schema: cs.schemaSpecToSchemaRef(endpoint.Response),
                                        },
                                },
                        },
                },
        }

        // Add request body for POST/PUT/PATCH
        if endpoint.Method == "POST" || endpoint.Method == "PUT" || endpoint.Method == "PATCH" </span><span class="cov8" title="1">{
                operation.RequestBody = &amp;RequestSpec{
                        Required: true,
                        Content: map[string]MediaSpec{
                                "application/json": {
                                        Schema: cs.schemaSpecToSchemaRef(endpoint.Request),
                                },
                        },
                }
        }</span>

        <span class="cov8" title="1">pathSpec[strings.ToLower(endpoint.Method)] = operation
        return pathSpec</span>
}

// schemaSpecToSchemaRef converts a schema spec to OpenAPI schema reference
func (cs *ContractSynthesizer) schemaSpecToSchemaRef(schema SchemaSpec) SchemaRefSpec <span class="cov8" title="1">{
        if len(schema.Fields) == 0 </span><span class="cov0" title="0">{
                return SchemaRefSpec{Type: "object"}
        }</span>

        <span class="cov8" title="1">properties := make(map[string]PropertySpec)
        required := []string{}

        for _, field := range schema.Fields </span><span class="cov8" title="1">{
                properties[field.Name] = PropertySpec{Type: field.Type}
                if field.Required </span><span class="cov8" title="1">{
                        required = append(required, field.Name)
                }</span>
        }

        <span class="cov8" title="1">return SchemaRefSpec{
                Type:       "object",
                Properties: properties,
                Required:   required,
        }</span>
}

// ApplySynthesisRules applies synthesis rules to resolve conflicts in proposals
func (cs *ContractSynthesizer) ApplySynthesisRules(proposals []*synthesis.Proposal) (*synthesis.SynthesisResult, error) <span class="cov8" title="1">{
        // Use the internal synthesizer
        synthesizer := synthesis.NewSynthesizer()

        for _, proposal := range proposals </span><span class="cov8" title="1">{
                synthesizer.AddProposal(proposal)
        }</span>

        <span class="cov8" title="1">return synthesizer.Synthesize()</span>
}

// WriteContract writes the agreed contract to a YAML file
func (cs *ContractSynthesizer) WriteContract(contract *OpenAPIContract, outputPath string) error <span class="cov8" title="1">{
        // Ensure directory exists
        dir := filepath.Dir(outputPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Marshal to YAML
        <span class="cov8" title="1">data, err := yaml.Marshal(contract)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal contract: %w", err)
        }</span>

        // Write file
        <span class="cov8" title="1">if err := os.WriteFile(outputPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write contract: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SynthesizeContract performs end-to-end contract synthesis
func (cs *ContractSynthesizer) SynthesizeContract(featureName, reqPath, outputPath string) (*synthesis.SynthesisResult, error) <span class="cov8" title="1">{
        // Step 1: Analyze requirements
        requirements, err := cs.AnalyzeRequirements(reqPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("analyze requirements failed: %w", err)
        }</span>

        // Step 2: Propose initial contract
        <span class="cov8" title="1">contract, err := cs.ProposeContract(requirements)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("propose contract failed: %w", err)
        }</span>

        // Step 3: Request agent reviews (in parallel)
        // For now, we'll simulate this with the synthesis rules
        // In a full implementation, this would use the Task tool to spawn agents

        // Step 4: Apply synthesis rules
        // For now, we'll use unanimous rule (no conflicts)
        <span class="cov8" title="1">proposals := []*synthesis.Proposal{
                synthesis.NewProposal(
                        "architect",
                        contract,
                        1.0,
                        "Initial contract from requirements",
                ),
        }

        result, err := cs.ApplySynthesisRules(proposals)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("apply synthesis rules failed: %w", err)
        }</span>

        // Step 5: Write agreed contract
        <span class="cov8" title="1">finalContract := result.Solution.(*OpenAPIContract)
        if err := cs.WriteContract(finalContract, outputPath); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("write contract failed: %w", err)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
