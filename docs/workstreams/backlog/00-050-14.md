---
ws_id: 00-050-14
parent: sdp-79u
feature: F050
status: backlog
size: SMALL
project_id: 00
---

## WS-00-050-14: Command Auto-Retry

### üéØ Goal

Implement automatic retry mechanism for failed Bash commands with exponential backoff. Reduce 13% command failure rate (4,904 failures from 36,868 commands in 827 sessions).

**What must WORK after completing this WS:**
- Detect command failures (exit code != 0)
- Retry with exponential backoff (1s ‚Üí 2s ‚Üí 4s)
- Max 3 retries before escalation
- Log retry attempts to telemetry
- Integration with TDD runner (auto-retry pytest)
- Integration with orchestrator (auto-retry subprocess calls)

**Acceptance Criteria:**
- [ ] AC1: Detect command failure (exit code != 0)
- [ ] AC2: Retry with exponential backoff (1s ‚Üí 2s ‚Üí 4s)
- [ ] AC3: Max 3 retries before human escalation
- [ ] AC4: Log retry attempts (timestamp, attempt#, error)
- [ ] AC5: Integration with TDD runner (pytest auto-retry)
- [ ] AC6: Integration with orchestrator (subprocess auto-retry)
- [ ] Coverage ‚â• 80%

**‚ö†Ô∏è WS is NOT complete until Goal is achieved (all AC ‚úÖ).**

---

### üìã Contracts

**Technical Constraints:**
- MUST use exponential backoff (1s, 2s, 4s delays)
- MUST log all retry attempts
- MUST not retry indefinitely (max 3 attempts)
- MUST integrate with existing TDD runner
- MUST integrate with orchestrator subprocess calls

---

### üîå Interfaces

```go
package retry

type RetryConfig struct {
    MaxAttempts int           // Maximum retry attempts (default: 3)
    BaseDelay   time.Duration // Initial delay (default: 1s)
    MaxDelay    time.Duration // Maximum delay (default: 4s)
}

type RetryResult struct {
    Success     bool
    Attempts    int
    TotalDelay  time.Duration
    Errors      []error
}

type Retrier struct {
    config RetryConfig
}

func NewRetrier(config RetryConfig) *Retrier
func (r *Retrier) Run(cmd *exec.Cmd) (*RetryResult, error)
func (r *Retrier) RunFunc(fn func() error) (*RetryResult, error)
```

---

### üìÅ Scope Files

**Implementation:**
- `internal/retry/retrier.go` - Retry logic with exponential backoff
- `internal/retry/telemetry.go` - Retry attempt logging
- `internal/retry/integration.go` - TDD runner + orchestrator integration

**Tests:**
- `internal/retry/retrier_test.go`

---

### ‚úÖ Testing

**Unit Tests:**
```bash
# Retry logic
TestExponentialBackoff()
TestMaxAttemptsRespected()
TestSuccessOnFirstAttempt()
TestSuccessOnRetry()
TestFailureAfterMaxRetries()

# Telemetry logging
TestRetryAttemptLogged()
TestTotalDelayCalculated()
```

**Integration Tests:**
```bash
# TDD runner integration
sdp build 00-050-02
# Simulate pytest failure, verify auto-retry

# Orchestrator integration
sdp oneshot F050
# Verify subprocess retries on failure
```

---

### üîç Verification

**Pre-build:**
- [ ] Review exponential backoff algorithm
- [ ] Verify max attempts enforcement
- [ ] Check telemetry logging format
- [ ] Test TDD runner integration

**Post-build:**
```bash
# Run tests
go test ./internal/retry/... -v -cover

# Manual integration test
# Create command that fails 2 times then succeeds
./sdp test-retry
# Should log 2 retries, succeed on 3rd attempt

# Verify telemetry
cat .sdp/telemetry.jsonl | grep "retry_attempt"
```

---

### üìù Notes

**Dependencies:** None (standalone utility)

**Context:**
Command failure reduction (from 13% to <5%). Based on usage data analysis: 4,904 command failures from 36,838 Bash commands across 827 sessions.

**Key Decisions:**
- Exponential backoff: 1s ‚Üí 2s ‚Üí 4s (doubling each time)
- Max 3 retries (total 4 attempts including initial)
- Integration with TDD runner (pytest auto-retry)
- Integration with orchestrator (subprocess auto-retry)
- Telemetry logging for all retry attempts

**Risks:**
- Exponential backoff too slow (mitigation: configurable delays)
- Too many retries waste time (mitigation: max 3 attempts)
- Retry loops hide persistent failures (mitigation: escalate after max)
- Integration complexity with TDD runner (mitigation: minimal changes)

**Mitigations:**
- Configurable delays via environment variables
- Strict max attempts enforcement
- Clear escalation after max retries
- Non-breaking integration (optional retry wrapper)

**Retry Logic Example:**
```go
func (r *Retrier) Run(cmd *exec.Cmd) (*RetryResult, error) {
    var errors []error
    var totalDelay time.Duration

    for attempt := 1; attempt <= r.config.MaxAttempts; attempt++ {
        err := cmd.Run()
        if err == nil {
            return &RetryResult{
                Success:    true,
                Attempts:   attempt,
                TotalDelay: totalDelay,
            }, nil
        }

        // Log retry
        log.Printf("Attempt %d/%d failed: %v", attempt, r.config.MaxAttempts, err)
        errors = append(errors, err)

        // Calculate delay (exponential backoff)
        delay := r.config.BaseDelay * time.Duration(1<<uint(attempt-1))
        if delay > r.config.MaxDelay {
            delay = r.config.MaxDelay
        }

        time.Sleep(delay)
        totalDelay += delay
    }

    return nil, fmt.Errorf("failed after %d attempts: %v", r.config.MaxAttempts, errors)
}
```

**Integration with TDD Runner:**
```go
func (t *TDDRunner) RedPhase() error {
    retrier := retry.NewRetrier(retry.RetryConfig{
        MaxAttempts: 3,
        BaseDelay:   1 * time.Second,
        MaxDelay:    4 * time.Second,
    })

    return retrier.RunFunc(func() error {
        return t.runPytest()  // May fail, will retry
    })
}
```

**Integration with Orchestrator:**
```go
func (o *Orchestrator) executeWithRetry(cmd *exec.Cmd) error {
    result, err := o.retrier.Run(cmd)
    if err != nil {
        return fmt.Errorf("command failed after retries: %w", err)
    }

    if !result.Success {
        o.telemetry.LogRetry(result)
    }

    return nil
}
```

**Telemetry Format:**
```json
{
  "timestamp": "2026-02-05T16:30:00Z",
  "event_type": "command_retry",
  "command": "pytest tests/",
  "attempt": 2,
  "max_attempts": 3,
  "delay_seconds": 2,
  "error": "exit status 1"
}
```

**Success Metrics:**
- Command failure rate reduced from 13% to <5%
- Retry telemetry captured for all failures
- TDD runner auto-retry works transparently
- Orchestrator subprocess retry works
- Zero breaking changes to existing workflows

**Future Work:**
- Configurable retry strategies (fibonacci backoff, jitter)
- Retry-specific exceptions (don't retry certain errors)
- Circuit breaker pattern for persistent failures
- Retry statistics dashboard
