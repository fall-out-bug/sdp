---
ws_id: 00-050-05
parent: sdp-79u
feature: F050
status: backlog
size: MEDIUM
project_id: 00
---

## WS-00-050-05: Quality Gates (Parallel Execution)

### ðŸŽ¯ Goal

Implement automated quality gates with parallel execution using goroutines. Reduce feedback delay from 30-60s to <10s through concurrent checks.

**What must WORK after completing this WS:**
- Run mypy, ruff, coverage in parallel (goroutines)
- File size check (<200 LOC per file)
- `sdp quality check` displays pass/fail per gate
- Exit code 1 if any gate fails
- Total execution time <8 seconds (vs Python's 8.5s)

**Acceptance Criteria:**
- [ ] AC1: Mypy gate runs in parallel with other gates
- [ ] AC2: Ruff gate runs in parallel with other gates
- [ ] AC3: Coverage gate runs in parallel with other gates
- [ ] AC4: File size gate validates all files <200 LOC
- [ ] AC5: `sdp quality check` displays results table
- [ ] AC6: Exit code 1 if any gate fails
- [ ] AC7: Total execution time <8 seconds
- [ ] Coverage â‰¥ 80%

**âš ï¸ WS is NOT complete until Goal is achieved (all AC âœ…).**

---

### ðŸ“‹ Contracts

**Technical Constraints:**
- Must use goroutines for parallel execution
- Must use sync.WaitGroup for coordination
- Must use channels for result aggregation
- Must run subprocess commands (not rewrite linters in Go)

---

### ðŸ”Œ Interfaces

```go
package quality

type Gate string

const (
    MypyGate      Gate = "mypy"
    RuffGate      Gate = "ruff"
    CoverageGate  Gate = "coverage"
    FileSizeGate  Gate = "file_size"
)

type GateResult struct {
    Gate      Gate
    Passed    bool
    Duration  time.Duration
    Output    string
    Error     error
}

type Checker struct {
    targetDir  string
    timeout    time.Duration
}

func (c *Checker) RunAll(ctx context.Context) ([]*GateResult, error)
func (c *Checker) runMypy(ctx context.Context) *GateResult
func (c *Checker) runRuff(ctx context.Context) *GateResult
func (c *Checker) runCoverage(ctx context.Context) *GateResult
func (c *Checker) runFileSize(ctx context.Context) *GateResult
```

---

### ðŸ“ Scope Files

**Implementation:**
- `internal/quality/checker.go`
- `internal/quality/gate.go`
- `internal/quality/mypy.go`
- `internal/quality/ruff.go`
- `internal/quality/coverage.go`
- `internal/quality/filesize.go`
- `cmd/sdp/commands/quality.go`

**Tests:**
- `internal/quality/checker_test.go`

---

### âœ… Testing

**Unit Tests:**
```bash
# Parallel execution
TestAllGatesRunInParallel()
TestGateExecutionTimeout()

# Individual gates
TestMypyGatePass()
TestMypyGateFail()
TestRuffGatePass()
TestRuffGateFail()
TestCoverageGatePass()
TestCoverageGateFail()
TestFileSizeGatePass()
TestFileSizeGateFail()

# Result aggregation
TestResultsAggregatedCorrectly()
TestExitCodeOnFailure()
```

**Integration Tests:**
```bash
# Full quality check
sdp quality check

# Expected output:
âœ… mypy: PASSED (0 errors)
âœ… ruff: PASSED (0 warnings)
âœ… coverage: 85% (target: 80%)
âœ… file size: all files <200 LOC

Total time: 6.2s
```

---

### ðŸ” Verification

**Pre-build:**
- [ ] Review goroutine coordination logic
- [ ] Verify timeout handling
- [ ] Check error propagation
- [ ] Verify parallel execution (not serial)

**Post-build:**
```bash
# Run tests
go test ./internal/quality/... -v -cover

# Manual integration test
time sdp quality check

# Expected: <8 seconds execution
```

---

### ðŸ“ Notes

**Dependencies:** 00-050-04

**Context:**
Parallel quality gates (700 LOC). Recommendation from deep-thinking: "Quality gates should run in parallel to reduce feedback delay from 30-60s to <10s."

**Key Decisions:**
- Goroutines for parallel execution (Go advantage)
- sync.WaitGroup for coordination
- Channels for result aggregation
- Subprocess calls to linters (not rewriting in Go)

**Risks:**
- Goroutine deadlock
- Timeout not propagating
- False negatives (gate passes when should fail)

**Mitigations:**
- Context cancellation for all goroutines
- Timeout per gate (not just total)
- Comprehensive integration testing

**Performance Target:**
- Python serial execution: 8.5s
- Go parallel execution: <8s
- Speedup: ~1.5x (not dramatic due to subprocess overhead)
